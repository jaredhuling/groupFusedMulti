% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_group_fused_multi.R
\name{cv.groupFusedMulti}
\alias{cv.groupFusedMulti}
\title{Cross Validation for the groupFusedMulti function}
\usage{
cv.groupFusedMulti(
  x,
  y,
  outcome.groups,
  lambda = NULL,
  lambda.fused = NULL,
  type.measure = c("mse", "deviance", "class", "auc", "mae", "brier"),
  nfolds = 10,
  foldid,
  grouped = TRUE,
  keep = FALSE,
  parallel = FALSE,
  ...
)
}
\arguments{
\item{x}{input matrix or SparseMatrix of dimension nobs x nvars. Each row is an observation,
each column corresponds to a covariate}

\item{y}{numeric response vector of length nobs}

\item{outcome.groups}{a vector of length equal to the number of columns in the outcome matrix \code{y}}

\item{lambda}{A user-specified sequence of lambda values. Left unspecified, the a sequence of lambda values is
automatically computed, ranging uniformly on the log scale over the relevant range of lambda values.}

\item{lambda.fused}{A user-specified sequence of fused lasso tuning parameters.}

\item{type.measure}{One of \code{c("mse","deviance","class","auc","mae","brier")} indicating measure to evaluate for cross-validation. The default is \code{type.measure = "deviance"}, 
which uses squared-error for gaussian models (a.k.a \code{type.measure = "mse"} there), deviance for logistic
regression. \code{type.measure = "class"} applies to binomial only. \code{type.measure = "auc"} is for two-class logistic 
regression only. \code{type.measure = "mse"} or \code{type.measure = "mae"} (mean absolute error) can be used by all models;
they measure the deviation from the fitted mean to the response. \code{type.measure = "brier"} is for models with 
\code{family = "coxph"} and will compute the Brier score.}

\item{nfolds}{number of folds for cross-validation. default is 10. 3 is smallest value allowed.}

\item{foldid}{an optional vector of values between 1 and nfold specifying which fold each observation belongs to.}

\item{grouped}{Like in \pkg{glmnet}, this is an experimental argument, with default \code{TRUE}, and can be ignored by most users. 
For all models, this refers to computing nfolds separate statistics, and then using their mean and estimated standard 
error to describe the CV curve. If \code{grouped = FALSE}, an error matrix is built up at the observation level from the 
predictions from the \code{nfold} fits, and then summarized (does not apply to \code{type.measure = "auc"}).}

\item{keep}{If \code{keep = TRUE}, a prevalidated list of arrasy is returned containing fitted values for each observation 
and each value of lambda for each model. This means these fits are computed with this observation and the rest of its
fold omitted. The folid vector is also returned. Default is \code{keep = FALSE}}

\item{parallel}{If TRUE, use parallel foreach to fit each fold. Must register parallel before hand, such as \pkg{doMC}.}

\item{...}{parameters to be passed to groupFusedMulti}
}
\value{
An object with S3 class "cv.groupFusedMulti"
}
\description{
Cross Validation for the groupFusedMulti function
}
\examples{

set.seed(123)

dat.sim <- gen_sparse_multivar_data(nvars = 15L,
                   noutcomes = 8L,
                   nobs = 100L,
                   nobs.test = 100L,
                   num.nonzero.vars = 10,
                   outcome.groups = rbind(c(1,1,1,2,2,2,2,2),
                                          c(1,1,1,2,2,3,3,3)))

x        <- dat.sim$x
x.test   <- dat.sim$x.test
y        <- dat.sim$y
y.test   <- dat.sim$y.test
beta     <- dat.sim$beta

\donttest{

outcome_groups <- rbind(c(1,1,1,2,2,2,2,2),
                        c(1,1,1,2,2,3,3,3))
                        
fit.adapt <- cv.groupFusedMulti(x, y,
                                nlambda        = 50,
                                lambda.fused = c(0.000005, 0.00001, 0.000025, 0.00005, 0.0001),
                                outcome.groups = outcome_groups,
                                adaptive.lasso = TRUE, adaptive.fused = TRUE,
                                gamma          = 0.25,
                                nfolds         = 5)

est.coefs <- predict(fit.adapt, type = "coef")
colnames(beta) <- colnames(est.coefs)

round(est.coefs, 3)
beta

preds.a <- predict(fit.adapt, x.test, type = 'response')

## rmse for each outcome
sqrt(colMeans((y.test - preds.a) ^ 2))

## avg rmse
mean(sqrt(colMeans((y.test - preds.a) ^ 2)))
                   
}
}
